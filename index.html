<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rookish</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #10b981;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
            --white: #ffffff;
            --board-light: #f0d9b5;
            --board-dark: #b58863;
            --highlight: #f6f669;
            --possible-move: rgba(34, 197, 94, 0.5);
            --last-move: rgba(255, 255, 0, 0.3);
            --check-highlight: rgba(239, 68, 68, 0.5);
            --castle-move: rgba(37, 99, 235, 0.5);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: var(--white);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: var(--dark);
            color: var(--white);
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-container {
            display: flex;
            gap: 30px;
            padding: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-section {
            flex: 1;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 500px;
            height: 500px;
            border: 3px solid var(--dark);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .square.light {
            background-color: var(--board-light);
        }

        .square.dark {
            background-color: var(--board-dark);
        }

        .square.selected {
            background-color: var(--highlight) !important;
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--secondary);
            border-radius: 50%;
            opacity: 0.5;
        }

        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border: 3px solid var(--danger);
            border-radius: 50%;
            opacity: 0.7;
        }

        .square.last-move {
            background-color: var(--last-move) !important;
        }

        .square.in-check {
            background-color: var(--check-highlight) !important;
            animation: pulse 1s infinite;
        }

        .square.castle-move::after {
            content: 'üè∞';
            position: absolute;
            font-size: 24px;
            opacity: 0.7;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }

        .piece {
            font-size: 48px;
            user-select: none;
            transition: transform 0.2s ease;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .controls-section {
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--light);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            color: var(--dark);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--white);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(37, 99, 235, 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: var(--white);
        }

        .btn-secondary:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: var(--danger);
            color: var(--white);
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-2px);
        }

        .btn.active {
            background: var(--dark);
            color: var(--white);
        }

        .status-display {
            padding: 15px;
            background: var(--white);
            border-radius: 8px;
            border-left: 4px solid var(--primary);
            margin-bottom: 10px;
        }

        .status-display.check {
            border-left-color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
        }

        .status-display.checkmate {
            border-left-color: var(--secondary);
            background: rgba(16, 185, 129, 0.1);
        }

        .status-display h3 {
            color: var(--dark);
            margin-bottom: 5px;
        }

        .status-display p {
            color: #6b7280;
            font-size: 14px;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: var(--white);
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
        }

        .move-item {
            padding: 5px;
            border-bottom: 1px solid #e5e7eb;
        }

        .move-item:last-child {
            border-bottom: none;
        }

        .captured-pieces {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 40px;
            padding: 10px;
            background: var(--white);
            border-radius: 8px;
        }

        .captured-piece {
            font-size: 24px;
            filter: grayscale(50%);
        }

        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--white);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            color: var(--dark);
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal-content p {
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: #6b7280;
            font-weight: bold;
        }

        .rank-label {
            left: 2px;
            top: 2px;
        }

        .file-label {
            right: 2px;
            bottom: 2px;
        }

        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .promotion-content {
            background: var(--white);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
        }

        .promotion-content h3 {
            color: var(--dark);
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .promotion-pieces {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 60px;
            cursor: pointer;
            transition: transform 0.2s ease;
            padding: 10px;
            border-radius: 8px;
        }

        .promotion-piece:hover {
            transform: scale(1.2);
            background: var(--light);
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }

            .board-section {
                min-width: auto;
            }

            .chess-board {
                width: 100%;
                max-width: 400px;
                height: 400px;
            }

            .piece {
                font-size: 36px;
            }

            .controls-section {
                flex: 1;
                width: 100%;
            }
        }

        .thinking-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--primary);
            color: var(--white);
            border-radius: 8px;
            margin-top: 10px;
        }

        .thinking-indicator.active {
            display: flex;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .special-move-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ôî Rookish ‚ôö</h1>
            <p>Challenge yourself against AI opponents with full chess rules</p>
        </header>

        <div class="game-container">
            <div class="board-section">
                <div class="chess-board" id="board"></div>
                <div class="thinking-indicator" id="thinkingIndicator">
                    <div class="spinner"></div>
                    <span>AI is thinking...</span>
                </div>
            </div>

            <div class="controls-section">
                <div class="card">
                    <h2>üéÆ Game Controls</h2>
                    <div class="status-display" id="statusDisplay">
                        <h3 id="gameStatus">Game Ready</h3>
                        <p id="currentTurn">White to move</p>
                    </div>
                    <button class="btn btn-primary" onclick="newGame()">New Game</button>
                    <button class="btn btn-secondary" onclick="undoMove()">Undo Move</button>
                    <button class="btn btn-danger" onclick="resignGame()">Resign</button>
                </div>

                <div class="card">
                    <h2>ü§ñ AI Difficulty</h2>
                    <div class="difficulty-buttons">
                        <button class="btn btn-primary" onclick="setDifficulty('easy')" id="easyBtn">Easy (Random)</button>
                        <button class="btn btn-primary" onclick="setDifficulty('medium')" id="mediumBtn">Medium (Basic)</button>
                        <button class="btn btn-primary" onclick="setDifficulty('hard')" id="hardBtn">Hard (Advanced)</button>
                    </div>
                </div>

                <div class="card">
                    <h2>üìã Move History</h2>
                    <div class="move-history" id="moveHistory"></div>
                </div>

                <div class="card">
                    <h2>‚ôü Captured Pieces</h2>
                    <div>
                        <p style="margin-bottom: 5px;">White captured:</p>
                        <div class="captured-pieces" id="whiteCaptured"></div>
                    </div>
                    <div style="margin-top: 10px;">
                        <p style="margin-bottom: 5px;">Black captured:</p>
                        <div class="captured-pieces" id="blackCaptured"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverMessage">The game has ended.</p>
            <button class="btn btn-primary" onclick="closeModal()">Play Again</button>
        </div>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <h3>Choose promotion piece:</h3>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        // Chess piece Unicode characters
        const PIECES = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // Game state
        let board = [];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let moveHistory = [];
        let capturedPieces = { white: [], black: [] };
        let lastMove = null;
        let difficulty = 'medium';
        let gameOver = false;
        let enPassantTarget = null;
        let castlingRights = {
            white: { kingside: true, queenside: true },
            black: { kingside: true, queenside: true }
        };
        let pendingPromotion = null;

        // Initialize board
        function initializeBoard() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
        }

        // Render board
        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add coordinates
                    if (col === 0) {
                        const rankLabel = document.createElement('span');
                        rankLabel.className = 'coordinates rank-label';
                        rankLabel.textContent = 8 - row;
                        square.appendChild(rankLabel);
                    }
                    if (row === 7) {
                        const fileLabel = document.createElement('span');
                        fileLabel.className = 'coordinates file-label';
                        fileLabel.textContent = String.fromCharCode(97 + col);
                        square.appendChild(fileLabel);
                    }

                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.from.row === row && lastMove.from.col === col) ||
                         (lastMove.to.row === row && lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }

                    // Highlight king in check
                    const piece = board[row][col];
                    if (piece && piece.toLowerCase() === 'k') {
                        const color = piece === piece.toUpperCase() ? 'white' : 'black';
                        if (isInCheck(color)) {
                            square.classList.add('in-check');
                        }
                    }

                    // Add piece
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        pieceElement.textContent = PIECES[piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // Handle square click
        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer === 'black') return;

            const piece = board[row][col];

            if (selectedSquare) {
                // Try to move
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    // Check for pawn promotion
                    if (board[selectedSquare.row][selectedSquare.col].toLowerCase() === 'p' && 
                        (row === 0 || row === 7)) {
                        pendingPromotion = {
                            from: { row: selectedSquare.row, col: selectedSquare.col },
                            to: { row, col }
                        };
                        showPromotionDialog();
                    } else {
                        makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    }
                    selectedSquare = null;
                    renderBoard();
                    
                    if (!gameOver && !pendingPromotion) {
                        currentPlayer = 'black';
                        updateStatus();
                        setTimeout(makeAIMove, 500);
                    }
                } else if (piece && isPieceOwnedByCurrentPlayer(piece)) {
                    // Select new piece
                    selectedSquare = { row, col };
                    renderBoard();
                    highlightSquare(row, col);
                    showPossibleMoves(row, col);
                } else {
                    // Deselect
                    selectedSquare = null;
                    renderBoard();
                }
            } else if (piece && isPieceOwnedByCurrentPlayer(piece)) {
                // Select piece
                selectedSquare = { row, col };
                renderBoard();
                highlightSquare(row, col);
                showPossibleMoves(row, col);
            }
        }

        // Show promotion dialog
        function showPromotionDialog() {
            const modal = document.getElementById('promotionModal');
            const piecesContainer = document.getElementById('promotionPieces');
            const isWhite = pendingPromotion.from.row === 6;
            
            piecesContainer.innerHTML = '';
            const pieces = ['Q', 'R', 'B', 'N'];
            const displayPieces = isWhite ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò'] : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
            
            pieces.forEach((piece, index) => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'promotion-piece';
                pieceElement.textContent = displayPieces[index];
                pieceElement.onclick = () => completePromotion(isWhite ? piece : piece.toLowerCase());
                piecesContainer.appendChild(pieceElement);
            });
            
            modal.style.display = 'flex';
        }

        // Complete pawn promotion
        function completePromotion(piece) {
            const modal = document.getElementById('promotionModal');
            modal.style.display = 'none';
            
            makeMove(pendingPromotion.from.row, pendingPromotion.from.col, 
                    pendingPromotion.to.row, pendingPromotion.to.col, piece);
            
            pendingPromotion = null;
            renderBoard();
            
            if (!gameOver) {
                currentPlayer = 'black';
                updateStatus();
                setTimeout(makeAIMove, 500);
            }
        }

        // Check if piece belongs to current player
        function isPieceOwnedByCurrentPlayer(piece) {
            if (currentPlayer === 'white') {
                return piece === piece.toUpperCase();
            } else {
                return piece === piece.toLowerCase();
            }
        }

        // Highlight selected square
        function highlightSquare(row, col) {
            const squares = document.querySelectorAll('.square');
            squares[row * 8 + col].classList.add('selected');
        }

        // Show possible moves
        function showPossibleMoves(row, col) {
            const squares = document.querySelectorAll('.square');
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const index = r * 8 + c;
                        const piece = board[row][col];
                        
                        // Check for castling
                        if (piece.toLowerCase() === 'k' && Math.abs(c - col) === 2) {
                            squares[index].classList.add('castle-move');
                        } else if (board[r][c]) {
                            squares[index].classList.add('possible-capture');
                        } else {
                            squares[index].classList.add('possible-move');
                        }
                    }
                }
            }
        }

        // Check if move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];

            if (!piece) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            if (targetPiece && isPieceOwnedByCurrentPlayer(targetPiece)) return false;

            const pieceType = piece.toLowerCase();
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);

            switch (pieceType) {
                case 'p':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, piece);
                case 'n':
                    return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
                case 'b':
                    return absRowDiff === absColDiff && isDiagonalClear(fromRow, fromCol, toRow, toCol);
                case 'r':
                    return (rowDiff === 0 || colDiff === 0) && isStraightClear(fromRow, fromCol, toRow, toCol);
                case 'q':
                    return ((rowDiff === 0 || colDiff === 0) && isStraightClear(fromRow, fromCol, toRow, toCol)) ||
                           (absRowDiff === absColDiff && isDiagonalClear(fromRow, fromCol, toRow, toCol));
                case 'k':
                    if (absRowDiff <= 1 && absColDiff <= 1) return true;
                    // Check for castling
                    if (absRowDiff === 0 && absColDiff === 2) {
                        return isValidCastling(fromRow, fromCol, toRow, toCol, piece);
                    }
                    return false;
                default:
                    return false;
            }
        }

        // Check if castling is valid
        function isValidCastling(fromRow, fromCol, toRow, toCol, piece) {
            const color = piece === piece.toUpperCase() ? 'white' : 'black';
            const row = color === 'white' ? 7 : 0;
            
            // King must be on starting row and not have moved
            if (fromRow !== row || fromCol !== 4) return false;
            
            // Check if castling rights are available
            if (toCol === 6) { // Kingside castling
                if (!castlingRights[color].kingside) return false;
                // Check if squares between king and rook are empty
                if (board[row][5] || board[row][6]) return false;
                // Check if king is not in check and doesn't pass through check
                if (isInCheck(color)) return false;
                // Simulate king move to f1/f8
                board[row][5] = piece;
                board[row][4] = null;
                const inCheckAfterF1 = isInCheck(color);
                board[row][4] = piece;
                board[row][5] = null;
                if (inCheckAfterF1) return false;
                // Simulate king move to g1/g8
                board[row][6] = piece;
                board[row][4] = null;
                const inCheckAfterG1 = isInCheck(color);
                board[row][4] = piece;
                board[row][6] = null;
                if (inCheckAfterG1) return false;
                return true;
            } else if (toCol === 2) { // Queenside castling
                if (!castlingRights[color].queenside) return false;
                // Check if squares between king and rook are empty
                if (board[row][3] || board[row][2] || board[row][1]) return false;
                // Check if king is not in check and doesn't pass through check
                if (isInCheck(color)) return false;
                // Simulate king move to d1/d8
                board[row][3] = piece;
                board[row][4] = null;
                const inCheckAfterD1 = isInCheck(color);
                board[row][4] = piece;
                board[row][3] = null;
                if (inCheckAfterD1) return false;
                // Simulate king move to c1/c8
                board[row][2] = piece;
                board[row][4] = null;
                const inCheckAfterC1 = isInCheck(color);
                board[row][4] = piece;
                board[row][2] = null;
                if (inCheckAfterC1) return false;
                return true;
            }
            return false;
        }

        // Check pawn move validity
        function isValidPawnMove(fromRow, fromCol, toRow, toCol, piece) {
            const direction = piece === piece.toUpperCase() ? -1 : 1;
            const startRow = piece === piece.toUpperCase() ? 6 : 1;
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);

            // Forward move
            if (colDiff === 0) {
                if (rowDiff === direction && !board[toRow][toCol]) return true;
                if (fromRow === startRow && rowDiff === 2 * direction && 
                    !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;
            }
            // Capture
            else if (colDiff === 1 && rowDiff === direction) {
                if (board[toRow][toCol]) return true;
                // En passant
                if (enPassantTarget && enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                    return true;
                }
            }
            return false;
        }

        // Check if diagonal path is clear
        function isDiagonalClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : -1;
            const colStep = toCol > fromCol ? 1 : -1;
            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow && col !== toCol) {
                if (board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            return true;
        }

        // Check if straight path is clear
        function isStraightClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow === fromRow ? 0 : (toRow > fromRow ? 1 : -1);
            const colStep = toCol === fromCol ? 0 : (toCol > fromCol ? 1 : -1);
            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow || col !== toCol) {
                if (board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            return true;
        }

        // Make move
        function makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            let moveNotation = '';

            // Handle capture
            if (capturedPiece) {
                const color = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
                capturedPieces[color].push(capturedPiece);
                updateCapturedPieces();
            }

            // Handle en passant
            if (piece.toLowerCase() === 'p' && enPassantTarget && 
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const capturedRow = piece === piece.toUpperCase() ? toRow + 1 : toRow - 1;
                const capturedPawn = board[capturedRow][toCol];
                const color = capturedPawn === capturedPawn.toUpperCase() ? 'white' : 'black';
                capturedPieces[color].push(capturedPawn);
                board[capturedRow][toCol] = null;
                updateCapturedPieces();
                moveNotation = 'e.p.';
            }

            // Handle castling
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                const row = piece === piece.toUpperCase() ? 7 : 0;
                if (toCol === 6) { // Kingside castling
                    board[row][5] = board[row][7];
                    board[row][7] = null;
                    moveNotation = 'O-O';
                } else if (toCol === 2) { // Queenside castling
                    board[row][3] = board[row][0];
                    board[row][0] = null;
                    moveNotation = 'O-O-O';
                }
            }

            // Update en passant target
            enPassantTarget = null;
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {
                    row: (fromRow + toRow) / 2,
                    col: fromCol
                };
            }

            // Move piece
            board[toRow][toCol] = promotionPiece || piece;
            board[fromRow][fromCol] = null;

            // Update castling rights
            if (piece.toLowerCase() === 'k') {
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                castlingRights[color].kingside = false;
                castlingRights[color].queenside = false;
            }
            if (piece.toLowerCase() === 'r') {
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                if (fromCol === 0) castlingRights[color].queenside = false;
                if (fromCol === 7) castlingRights[color].kingside = false;
            }

            // Generate move notation
            if (!moveNotation) {
                const files = 'abcdefgh';
                const pieceNotation = piece.toLowerCase() === 'p' ? '' : piece.toUpperCase();
                const captureNotation = capturedPiece ? 'x' : '';
                const from = piece.toLowerCase() === 'p' && capturedPiece ? 
                    files[fromCol] : '';
                const to = files[toCol] + (8 - toRow);
                moveNotation = pieceNotation + from + captureNotation + to;
                
                if (promotionPiece) {
                    moveNotation += '=' + promotionPiece.toUpperCase();
                }
            }

            // Record move
            const move = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece,
                captured: capturedPiece,
                notation: moveNotation,
                promotion: promotionPiece
            };
            moveHistory.push(move);
            lastMove = move;
            updateMoveHistory();

            // Check for checkmate or stalemate
            const nextPlayer = currentPlayer === 'white' ? 'black' : 'white';
            if (isInCheck(nextPlayer)) {
                if (isCheckmate(nextPlayer)) {
                    gameOver = true;
                    showGameOver(`Checkmate! ${currentPlayer === 'white' ? 'White' : 'Black'} wins!`);
                } else {
                    updateStatus(`${nextPlayer === 'white' ? 'White' : 'Black'} is in check!`, true);
                }
            } else if (isStalemate(nextPlayer)) {
                gameOver = true;
                showGameOver('Stalemate! The game is a draw.');
            } else {
                updateStatus();
            }
        }

        // Check if king is in check
        function isInCheck(color) {
            const kingPiece = color === 'white' ? 'K' : 'k';
            let kingPos = null;

            // Find king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingPos = { row, col };
                        break;
                    }
                }
            }

            if (!kingPos) return false;

            // Check if any opponent piece can attack the king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && !isPieceOwnedByCurrentPlayer(piece)) {
                        const tempPlayer = currentPlayer;
                        currentPlayer = color === 'white' ? 'black' : 'white';
                        if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                            currentPlayer = tempPlayer;
                            return true;
                        }
                        currentPlayer = tempPlayer;
                    }
                }
            }
            return false;
        }

        // Check for checkmate
        function isCheckmate(color) {
            if (!isInCheck(color)) return false;

            // Try all possible moves
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && (color === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck(color);

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;

                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        // Check for stalemate
        function isStalemate(color) {
            if (isInCheck(color)) return false;

            // Try all possible moves
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && (color === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck(color);

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;

                                    if (!stillInCheck) return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        // AI move
        function makeAIMove() {
            if (gameOver) return;

            document.getElementById('thinkingIndicator').classList.add('active');

            setTimeout(() => {
                let move;
                switch (difficulty) {
                    case 'easy':
                        move = getRandomMove();
                        break;
                    case 'medium':
                        move = getMediumMove();
                        break;
                    case 'hard':
                        move = getHardMove();
                        break;
                }

                if (move) {
                    // Check for AI pawn promotion
                    if (board[move.from.row][move.from.col].toLowerCase() === 'p' && 
                        (move.to.row === 0 || move.to.row === 7)) {
                        // AI always promotes to queen
                        makeMove(move.from.row, move.from.col, move.to.row, move.to.col, 
                                currentPlayer === 'black' ? 'q' : 'Q');
                    } else {
                        makeMove(move.from.row, move.from.col, move.to.row, move.to.col);
                    }
                    renderBoard();
                    currentPlayer = 'white';
                    updateStatus();
                }

                document.getElementById('thinkingIndicator').classList.remove('active');
            }, 300);
        }

        // Get random move (Easy difficulty)
        function getRandomMove() {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece === piece.toLowerCase()) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck('black');

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;

                                    if (!stillInCheck) {
                                        moves.push({ from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
        }

        // Get medium difficulty move
        function getMediumMove() {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece === piece.toLowerCase()) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck('black');
                                    const givesCheck = isInCheck('white');

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;

                                    if (!stillInCheck) {
                                        let score = 0;
                                        if (temp) score += getPieceValue(temp);
                                        if (givesCheck) score += 50;
                                        // Bonus for castling
                                        if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                                            score += 30;
                                        }
                                        moves.push({ 
                                            from: { row: fromRow, col: fromCol }, 
                                            to: { row: toRow, col: toCol },
                                            score: score
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (moves.length === 0) return null;
            
            moves.sort((a, b) => b.score - a.score);
            const topMoves = moves.filter(m => m.score === moves[0].score);
            return topMoves[Math.floor(Math.random() * topMoves.length)];
        }

        // Get hard difficulty move
        function getHardMove() {
            let bestMove = null;
            let bestScore = -Infinity;

            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece === piece.toLowerCase()) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck('black');

                                    if (!stillInCheck) {
                                        const score = minimax(3, false, -Infinity, Infinity);
                                        if (score > bestScore) {
                                            bestScore = score;
                                            bestMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
                                        }
                                    }

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;
                                }
                            }
                        }
                    }
                }
            }

            return bestMove;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, isMaximizing, alpha, beta) {
            if (depth === 0) {
                return evaluateBoard();
            }

            const color = isMaximizing ? 'black' : 'white';
            const moves = [];

            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && (isMaximizing ? piece === piece.toLowerCase() : piece === piece.toUpperCase())) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Make move
                                    const temp = board[toRow][toCol];
                                    board[toRow][toCol] = piece;
                                    board[fromRow][fromCol] = null;

                                    const stillInCheck = isInCheck(color);

                                    // Undo move
                                    board[fromRow][fromCol] = piece;
                                    board[toRow][toCol] = temp;

                                    if (!stillInCheck) {
                                        moves.push({ from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (moves.length === 0) {
                if (isInCheck(color)) {
                    return isMaximizing ? -10000 : 10000;
                }
                return 0;
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const temp = board[move.to.row][move.to.col];
                    board[move.to.row][move.to.col] = board[move.from.row][move.from.col];
                    board[move.from.row][move.from.col] = null;

                    const eval = minimax(depth - 1, false, alpha, beta);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);

                    board[move.from.row][move.from.col] = board[move.to.row][move.to.col];
                    board[move.to.row][move.to.col] = temp;

                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const temp = board[move.to.row][move.to.col];
                    board[move.to.row][move.to.col] = board[move.from.row][move.from.col];
                    board[move.from.row][move.from.col] = null;

                    const eval = minimax(depth - 1, true, alpha, beta);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);

                    board[move.from.row][move.from.col] = board[move.to.row][move.to.col];
                    board[move.to.row][move.to.col] = temp;

                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // Evaluate board position
        function evaluateBoard() {
            let score = 0;
            const pieceValues = { 'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900 };

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = pieceValues[piece.toLowerCase()];
                        if (piece === piece.toLowerCase()) {
                            score += value;
                        } else {
                            score -= value;
                        }
                    }
                }
            }

            return score;
        }

        // Get piece value
        function getPieceValue(piece) {
            const values = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 100 };
            return values[piece.toLowerCase()];
        }

        // Update status display
        function updateStatus(message, isCheck = false) {
            const statusDisplay = document.getElementById('statusDisplay');
            const statusElement = document.getElementById('gameStatus');
            const turnElement = document.getElementById('currentTurn');
            
            statusDisplay.className = 'status-display';
            if (isCheck) {
                statusDisplay.classList.add('check');
            }
            
            if (message) {
                statusElement.textContent = message;
            } else {
                statusElement.textContent = 'Game in Progress';
            }
            
            turnElement.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'} to move`;
        }

        // Update move history
        function updateMoveHistory() {
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = '';
            
            moveHistory.forEach((move, index) => {
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';
                const moveNumber = Math.floor(index / 2) + 1;
                const prefix = index % 2 === 0 ? `${moveNumber}.` : '...';
                moveItem.textContent = `${prefix} ${move.notation}`;
                historyElement.appendChild(moveItem);
            });
            
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Update captured pieces
        function updateCapturedPieces() {
            const whiteCapturedElement = document.getElementById('whiteCaptured');
            const blackCapturedElement = document.getElementById('blackCaptured');
            
            whiteCapturedElement.innerHTML = '';
            blackCapturedElement.innerHTML = '';
            
            capturedPieces.white.forEach(piece => {
                const pieceElement = document.createElement('span');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = PIECES[piece];
                whiteCapturedElement.appendChild(pieceElement);
            });
            
            capturedPieces.black.forEach(piece => {
                const pieceElement = document.createElement('span');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = PIECES[piece];
                blackCapturedElement.appendChild(pieceElement);
            });
        }

        // Set difficulty
        function setDifficulty(level) {
            difficulty = level;
            
            // Update button states
            document.querySelectorAll('.difficulty-buttons .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(level + 'Btn').classList.add('active');
        }

        // New game
        function newGame() {
            initializeBoard();
            currentPlayer = 'white';
            selectedSquare = null;
            moveHistory = [];
            capturedPieces = { white: [], black: [] };
            lastMove = null;
            gameOver = false;
            enPassantTarget = null;
            castlingRights = {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            };
            pendingPromotion = null;
            
            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCapturedPieces();
            closeModal();
        }

        // Undo move
        function undoMove() {
            if (moveHistory.length < 2) return;
            
            // Undo AI move
            const aiMove = moveHistory.pop();
            board[aiMove.from.row][aiMove.from.col] = aiMove.piece;
            board[aiMove.to.row][aiMove.to.col] = aiMove.captured;
            
            // Undo player move
            const playerMove = moveHistory.pop();
            board[playerMove.from.row][playerMove.from.col] = playerMove.piece;
            board[playerMove.to.row][playerMove.to.col] = playerMove.captured;
            
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
            currentPlayer = 'white';
            
            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCapturedPieces();
        }

        // Resign game
        function resignGame() {
            gameOver = true;
            const winner = currentPlayer === 'white' ? 'Black' : 'White';
            showGameOver(`${currentPlayer === 'white' ? 'White' : 'Black'} resigns. ${winner} wins!`);
        }

        // Show game over modal
        function showGameOver(message) {
            const statusDisplay = document.getElementById('statusDisplay');
            statusDisplay.className = 'status-display checkmate';
            
            document.getElementById('gameOverTitle').textContent = 'Game Over!';
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        // Close modal
        function closeModal() {
            document.getElementById('gameOverModal').style.display = 'none';
        }

        // Initialize game
        initializeBoard();
        renderBoard();
        setDifficulty('medium');
        updateStatus();
    </script>
</body>
</html>
